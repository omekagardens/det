<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DET Mind Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        /* 3D Visualization Panel */
        #visualization {
            flex: 1;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        /* Side Panel */
        #panel {
            width: 320px;
            background: #12122a;
            border-left: 1px solid #2a2a4a;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            background: linear-gradient(135deg, #1a1a3a 0%, #0d0d1f 100%);
            padding: 15px;
            border-bottom: 1px solid #2a2a4a;
        }

        .panel-header h1 {
            font-size: 1.2rem;
            color: #00d4ff;
            margin-bottom: 5px;
        }

        .panel-header .subtitle {
            font-size: 0.75rem;
            color: #888;
        }

        /* Tabs */
        .tabs {
            display: flex;
            flex-wrap: wrap;
            background: #0d0d1f;
            border-bottom: 1px solid #2a2a4a;
        }

        .tab {
            flex: 1 1 auto;
            min-width: 50px;
            padding: 8px 6px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #888;
            font-size: 0.7rem;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab:hover {
            color: #ccc;
            background: rgba(255,255,255,0.05);
        }

        .tab.active {
            color: #00d4ff;
            background: rgba(0,212,255,0.1);
            border-bottom: 2px solid #00d4ff;
        }

        /* Tab Content */
        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        /* Status Section */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .status-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 12px;
        }

        .status-card .label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .status-card .value {
            font-size: 1.4rem;
            font-weight: 600;
            color: #fff;
        }

        .status-card.emotion .value {
            font-size: 1rem;
            color: #00d4ff;
        }

        /* Affect Display */
        .affect-bars {
            margin-bottom: 20px;
        }

        .affect-bar {
            margin-bottom: 12px;
        }

        .affect-bar .header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.75rem;
        }

        .affect-bar .bar {
            height: 8px;
            background: #1a1a3a;
            border-radius: 4px;
            overflow: hidden;
        }

        .affect-bar .fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .affect-bar.valence .fill {
            background: linear-gradient(90deg, #ff4444, #888, #44ff44);
        }

        .affect-bar.arousal .fill {
            background: linear-gradient(90deg, #333, #ff8800);
        }

        .affect-bar.bondedness .fill {
            background: linear-gradient(90deg, #333, #00d4ff);
        }

        /* Controls */
        .controls {
            margin-bottom: 20px;
        }

        .control-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .btn {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #00d4ff;
            color: #000;
        }

        .btn-primary:hover {
            background: #00a8cc;
        }

        .btn-secondary {
            background: #2a2a4a;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #3a3a5a;
        }

        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-success {
            background: #44aa44;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-danger {
            background: #ff4444;
            color: #fff;
        }

        .btn-danger:hover {
            background: #cc3333;
        }

        .btn.active {
            background: #ff8800;
            color: #000;
        }

        /* Speed Control */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .speed-control label {
            font-size: 0.8rem;
            color: #888;
        }

        .speed-control input {
            flex: 1;
        }

        .speed-control .value {
            width: 50px;
            text-align: right;
            font-size: 0.85rem;
        }

        /* Log Panel */
        .log-container {
            background: #0a0a1a;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.75rem;
        }

        .log-entry {
            padding: 6px 10px;
            border-bottom: 1px solid #1a1a2a;
        }

        .log-entry:hover {
            background: rgba(255,255,255,0.03);
        }

        .log-entry .time {
            color: #666;
            margin-right: 8px;
        }

        .log-entry .type {
            color: #00d4ff;
            margin-right: 8px;
        }

        /* Node List */
        .node-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .node-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #1a1a2a;
            cursor: pointer;
        }

        .node-item:hover {
            background: rgba(255,255,255,0.03);
        }

        .node-item .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .node-item .info {
            flex: 1;
        }

        .node-item .name {
            font-size: 0.85rem;
        }

        .node-item .stats {
            font-size: 0.7rem;
            color: #888;
        }

        .node-item.in-self {
            background: rgba(0,212,255,0.1);
        }

        /* Chat Interface */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            margin-bottom: 10px;
            min-height: 200px;
        }

        .chat-message {
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 8px;
        }

        .chat-message.user {
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid #00d4ff;
        }

        .chat-message.assistant {
            background: rgba(255, 136, 0, 0.1);
            border-left: 3px solid #ff8800;
        }

        .chat-message.system {
            background: rgba(255, 255, 255, 0.05);
            font-size: 0.8rem;
            color: #888;
            font-style: italic;
        }

        .chat-message .sender {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .chat-message .content {
            font-size: 0.85rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .chat-input-container {
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            padding: 12px;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            background: #0a0a1a;
            color: #fff;
            font-size: 0.9rem;
            resize: none;
        }

        .chat-input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .chat-input::placeholder {
            color: #666;
        }

        .chat-send-btn {
            padding: 12px 20px;
            background: #00d4ff;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        .chat-send-btn:hover {
            background: #00a8cc;
        }

        .chat-send-btn:disabled {
            background: #2a2a4a;
            color: #666;
            cursor: not-allowed;
        }

        .chat-status {
            font-size: 0.75rem;
            color: #888;
            margin-top: 8px;
            text-align: center;
        }

        .chat-status.processing {
            color: #ff8800;
        }

        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            z-index: 100;
        }

        .connection-status.connected {
            background: rgba(68, 255, 68, 0.2);
            color: #44ff44;
        }

        .connection-status.disconnected {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        /* Somatic Panel Styles */
        .somatic-section {
            margin-bottom: 20px;
        }

        .somatic-section h3 {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #2a2a4a;
        }

        .somatic-create-form {
            background: rgba(255,255,255,0.03);
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .somatic-create-form select,
        .somatic-create-form input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #2a2a4a;
            border-radius: 4px;
            background: #0a0a1a;
            color: #fff;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .somatic-create-form select:focus,
        .somatic-create-form input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .somatic-type-group {
            margin-bottom: 8px;
        }

        .somatic-type-group label {
            display: block;
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 4px;
        }

        .somatic-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .somatic-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .somatic-item.sensor {
            border-left: 3px solid #4488ff;
        }

        .somatic-item.actuator {
            border-left: 3px solid #ff8844;
        }

        .somatic-item .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .somatic-item .name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .somatic-item .type-badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
        }

        .somatic-item.sensor .type-badge {
            background: rgba(68, 136, 255, 0.2);
            color: #4488ff;
        }

        .somatic-item.actuator .type-badge {
            background: rgba(255, 136, 68, 0.2);
            color: #ff8844;
        }

        .somatic-item .values {
            display: flex;
            gap: 15px;
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 8px;
        }

        .somatic-item .values span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .somatic-item .values .val {
            color: #fff;
            font-family: monospace;
        }

        .somatic-item .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .somatic-item .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .somatic-item input[type="range"] {
            flex: 1;
            height: 4px;
        }

        .somatic-item .slider-value {
            width: 40px;
            font-size: 0.75rem;
            text-align: right;
            font-family: monospace;
        }

        .somatic-item .btn-remove {
            padding: 4px 8px;
            font-size: 0.7rem;
            background: #442222;
            color: #ff6666;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .somatic-item .btn-remove:hover {
            background: #ff4444;
            color: #fff;
        }

        .somatic-empty {
            text-align: center;
            color: #666;
            padding: 20px;
            font-size: 0.85rem;
        }

        /* Overlay info */
        #overlay-info {
            position: absolute;
            top: 10px;
            right: 330px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8rem;
        }

        #overlay-info .row {
            margin-bottom: 5px;
        }

        #overlay-info .label {
            color: #888;
            margin-right: 8px;
        }

        #paused-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 100, 100, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 2rem;
            font-weight: bold;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: pausePulse 2s infinite;
        }

        @keyframes pausePulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="visualization">
            <div id="canvas-container"></div>
            <div id="paused-indicator" style="display: none;">‚è∏ PAUSED</div>
            <div id="overlay-info">
                <div class="row"><span class="label">Tick:</span><span id="info-tick">0</span></div>
                <div class="row"><span class="label">Nodes:</span><span id="info-nodes">0</span></div>
                <div class="row"><span class="label">Bonds:</span><span id="info-bonds">0</span></div>
                <div class="row"><span class="label">Self:</span><span id="info-self">0</span></div>
            </div>
        </div>

        <div id="panel">
            <div class="panel-header">
                <h1>DET Mind Viewer</h1>
                <div class="subtitle">Deep Existence Theory Visualization</div>
            </div>

            <div class="tabs">
                <button class="tab active" data-tab="status">Status</button>
                <button class="tab" data-tab="chat">Chat</button>
                <button class="tab" data-tab="control">Control</button>
                <button class="tab" data-tab="somatic">Somatic</button>
                <button class="tab" data-tab="nodes">Nodes</button>
                <button class="tab" data-tab="log">Log</button>
            </div>

            <div class="tab-content">
                <!-- Status Tab -->
                <div class="tab-pane active" id="tab-status">
                    <div class="status-grid">
                        <div class="status-card">
                            <div class="label">Presence</div>
                            <div class="value" id="stat-presence">0.00</div>
                        </div>
                        <div class="status-card">
                            <div class="label">Coherence</div>
                            <div class="value" id="stat-coherence">0.00</div>
                        </div>
                        <div class="status-card">
                            <div class="label">Resource</div>
                            <div class="value" id="stat-resource">0.00</div>
                        </div>
                        <div class="status-card">
                            <div class="label">Debt</div>
                            <div class="value" id="stat-debt">0.00</div>
                        </div>
                        <div class="status-card emotion" style="grid-column: span 2;">
                            <div class="label">Emotional State</div>
                            <div class="value" id="stat-emotion">NEUTRAL</div>
                        </div>
                    </div>

                    <h3 style="font-size: 0.9rem; margin-bottom: 10px; color: #888;">Affect</h3>
                    <div class="affect-bars">
                        <div class="affect-bar valence">
                            <div class="header">
                                <span>Valence</span>
                                <span id="affect-valence-val">0.00</span>
                            </div>
                            <div class="bar">
                                <div class="fill" id="affect-valence-bar" style="width: 50%;"></div>
                            </div>
                        </div>
                        <div class="affect-bar arousal">
                            <div class="header">
                                <span>Arousal</span>
                                <span id="affect-arousal-val">0.00</span>
                            </div>
                            <div class="bar">
                                <div class="fill" id="affect-arousal-bar" style="width: 0%;"></div>
                            </div>
                        </div>
                        <div class="affect-bar bondedness">
                            <div class="header">
                                <span>Bondedness</span>
                                <span id="affect-bondedness-val">0.00</span>
                            </div>
                            <div class="bar">
                                <div class="fill" id="affect-bondedness-bar" style="width: 0%;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Chat Tab -->
                <div class="tab-pane" id="tab-chat">
                    <div class="chat-container">
                        <div class="chat-messages" id="chat-messages">
                            <div class="chat-message system">
                                <div class="content">Welcome to DET Chat. Type a message to interact with the DET-modulated LLM.</div>
                            </div>
                        </div>
                        <div class="chat-input-container">
                            <textarea class="chat-input" id="chat-input" rows="2" placeholder="Type your message..."></textarea>
                            <button class="chat-send-btn" id="chat-send">Send</button>
                        </div>
                        <div class="chat-status" id="chat-status">Ready</div>
                    </div>
                </div>

                <!-- Control Tab -->
                <div class="tab-pane" id="tab-control">
                    <div class="controls">
                        <div class="control-row">
                            <button class="btn btn-primary" id="btn-step">Step</button>
                            <button class="btn btn-secondary" id="btn-step10">Step 10</button>
                        </div>
                        <div class="control-row">
                            <button class="btn btn-secondary" id="btn-pause">Pause</button>
                            <button class="btn btn-secondary" id="btn-resume">Resume</button>
                        </div>
                        <div class="speed-control">
                            <label>Speed:</label>
                            <input type="range" id="speed-slider" min="0.1" max="5" step="0.1" value="1">
                            <span class="value" id="speed-value">1.0x</span>
                        </div>
                        <div class="control-row">
                            <button class="btn btn-secondary" id="btn-snapshot">Snapshot</button>
                            <button class="btn btn-secondary" id="btn-restore">Restore</button>
                        </div>
                    </div>

                    <h3 style="font-size: 0.9rem; margin-bottom: 10px; color: #888;">Inject Resources</h3>
                    <div class="control-row">
                        <input type="number" id="inject-node" placeholder="Node" style="width: 60px; padding: 8px; border-radius: 4px; border: 1px solid #2a2a4a; background: #0a0a1a; color: #fff;">
                        <input type="number" id="inject-amount" placeholder="Amount" step="0.1" value="0.5" style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #2a2a4a; background: #0a0a1a; color: #fff;">
                        <button class="btn btn-primary" id="btn-inject">Inject F</button>
                    </div>
                </div>

                <!-- Somatic Tab -->
                <div class="tab-pane" id="tab-somatic">
                    <div class="somatic-section">
                        <h3>Create Somatic Node</h3>
                        <div class="somatic-create-form">
                            <div class="somatic-type-group">
                                <label>Node Type</label>
                                <select id="somatic-type-select">
                                    <optgroup label="Sensors (Afferent)">
                                        <option value="0">Temperature</option>
                                        <option value="1">Humidity</option>
                                        <option value="2">Light</option>
                                        <option value="3">Motion (PIR)</option>
                                        <option value="4">Sound</option>
                                        <option value="5">Pressure</option>
                                        <option value="6">Proximity</option>
                                        <option value="7">Accelerometer</option>
                                        <option value="8">Gyroscope</option>
                                        <option value="9">Compass</option>
                                        <option value="10">GPS</option>
                                        <option value="11">Touch</option>
                                        <option value="12">pH</option>
                                        <option value="13">Gas</option>
                                        <option value="14">Current</option>
                                        <option value="15">Generic Sensor</option>
                                    </optgroup>
                                    <optgroup label="Actuators (Efferent)">
                                        <option value="16">Switch/Relay</option>
                                        <option value="17">Motor</option>
                                        <option value="18">LED</option>
                                        <option value="19">Servo</option>
                                        <option value="20">Speaker</option>
                                        <option value="21">Display</option>
                                        <option value="22">Pump</option>
                                        <option value="23">Valve</option>
                                        <option value="24">Heater</option>
                                        <option value="25">Fan</option>
                                        <option value="31">Generic Actuator</option>
                                    </optgroup>
                                </select>
                            </div>
                            <input type="text" id="somatic-name-input" placeholder="Node name (e.g., room_temp)">
                            <button class="btn btn-primary" id="btn-create-somatic" style="width: 100%;">Create Node</button>
                        </div>
                    </div>

                    <div class="somatic-section">
                        <h3>Active Nodes <span id="somatic-count" style="color: #00d4ff;">(0)</span></h3>
                        <div class="somatic-list" id="somatic-list">
                            <div class="somatic-empty">No somatic nodes. Create one above.</div>
                        </div>
                    </div>

                    <div class="control-row" style="margin-top: 10px;">
                        <button class="btn btn-secondary" id="btn-simulate-somatic">Simulate Step</button>
                        <button class="btn btn-secondary" id="btn-refresh-somatic">Refresh</button>
                    </div>
                </div>

                <!-- Nodes Tab -->
                <div class="tab-pane" id="tab-nodes">
                    <div class="node-list" id="node-list">
                        <!-- Populated dynamically -->
                    </div>
                </div>

                <!-- Log Tab -->
                <div class="tab-pane" id="tab-log">
                    <div class="log-container" id="log-container">
                        <!-- Populated dynamically -->
                    </div>
                    <div class="control-row" style="margin-top: 10px;">
                        <button class="btn btn-secondary" id="btn-clear-log">Clear Log</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="connection-status disconnected" id="connection-status">
        Disconnected
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // ============================================================
        // DET Mind Viewer - Main Application
        // ============================================================

        class DETViewer {
            constructor() {
                this.ws = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.nodes = new Map();
                this.bonds = [];
                this.selfCluster = new Set();

                this.state = {
                    tick: 0,
                    paused: false,
                    speed: 1.0,
                    numActive: 0,
                    numBonds: 0,
                };

                this.logs = [];
                this.maxLogs = 100;

                this.init();
            }

            init() {
                this.initThree();
                this.initWebSocket();
                this.initControls();
                this.initTabs();
                this.initChat();
                this.initSomatic();
                this.animate();
            }

            chatProcessing = false;

            // --------------------------------------------------------
            // Three.js Setup
            // --------------------------------------------------------

            initThree() {
                const container = document.getElementById('canvas-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050510);

                // Camera
                this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                this.camera.position.set(10, 8, 10);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(this.renderer.domElement);

                // Controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;

                // Lights
                const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
                this.scene.add(ambientLight);

                const pointLight = new THREE.PointLight(0xffffff, 0.8);
                pointLight.position.set(10, 10, 10);
                this.scene.add(pointLight);

                const pointLight2 = new THREE.PointLight(0x4488ff, 0.5);
                pointLight2.position.set(-10, 5, -10);
                this.scene.add(pointLight2);

                // Grid helper (subtle)
                const gridHelper = new THREE.GridHelper(20, 20, 0x101025, 0x101025);
                gridHelper.position.y = -3;
                this.scene.add(gridHelper);

                // Domain labels (visual markers for LLM areas)
                this.domainLabels = new Map();
                const domainColors = {
                    'math': 0xff6666,
                    'language': 0x66ff66,
                    'tool_use': 0x6666ff,
                    'science': 0xffff66
                };
                const domainAngles = { 'math': 0, 'language': Math.PI/2, 'tool_use': Math.PI, 'science': Math.PI*1.5 };

                Object.entries(domainAngles).forEach(([domain, angle]) => {
                    const markerGeom = new THREE.RingGeometry(5.5, 6, 32, 1, angle - 0.3, 0.6);
                    const markerMat = new THREE.MeshBasicMaterial({
                        color: domainColors[domain],
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.DoubleSide
                    });
                    const marker = new THREE.Mesh(markerGeom, markerMat);
                    marker.rotation.x = -Math.PI / 2;
                    marker.position.y = -2.9;
                    this.scene.add(marker);
                    this.domainLabels.set(domain, marker);
                });

                // Node visual state (for smooth movement)
                this.nodePositions = new Map();  // id -> {x, y, z, vx, vy, vz}
                this.nodeTargets = new Map();    // id -> {x, y, z}

                // Info flow particles
                this.flowParticles = [];
                this.particleGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                this.particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });

                // Resize handler
                window.addEventListener('resize', () => {
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    this.camera.aspect = w / h;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(w, h);
                });

                // Start animation loop
                this.lastTime = performance.now();
                this.animate();
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 0.1);
                this.lastTime = now;

                // Update node positions with smooth interpolation
                this.nodes.forEach((mesh, id) => {
                    const pos = this.nodePositions.get(id);
                    const target = this.nodeTargets.get(id);
                    if (pos && target) {
                        // Spring-like movement toward target
                        const k = 3.0;  // Spring constant
                        const damping = 0.8;

                        pos.vx += (target.x - pos.x) * k * dt;
                        pos.vy += (target.y - pos.y) * k * dt;
                        pos.vz += (target.z - pos.z) * k * dt;

                        pos.vx *= damping;
                        pos.vy *= damping;
                        pos.vz *= damping;

                        pos.x += pos.vx * dt;
                        pos.y += pos.vy * dt;
                        pos.z += pos.vz * dt;

                        mesh.position.set(pos.x, pos.y, pos.z);
                    }
                });

                // Update bond positions to follow nodes
                this.updateBondPositions();

                // Update info flow particles
                this.updateFlowParticles(dt);

                // Render
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            updateBondPositions() {
                // Update bond line positions to follow moving nodes
                this.bonds.forEach(bondObj => {
                    if (bondObj.line && bondObj.sourceId !== undefined) {
                        const sourceNode = this.nodes.get(bondObj.sourceId);
                        const targetNode = this.nodes.get(bondObj.targetId);
                        if (sourceNode && targetNode) {
                            const positions = bondObj.line.geometry.attributes.position.array;
                            positions[0] = sourceNode.position.x;
                            positions[1] = sourceNode.position.y;
                            positions[2] = sourceNode.position.z;
                            positions[3] = targetNode.position.x;
                            positions[4] = targetNode.position.y;
                            positions[5] = targetNode.position.z;
                            bondObj.line.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                });
            }

            updateFlowParticles(dt) {
                // Move particles along bonds
                for (let i = this.flowParticles.length - 1; i >= 0; i--) {
                    const particle = this.flowParticles[i];
                    particle.progress += particle.speed * dt;

                    if (particle.progress >= 1) {
                        this.scene.remove(particle.mesh);
                        this.flowParticles.splice(i, 1);
                    } else {
                        const sourceNode = this.nodes.get(particle.sourceId);
                        const targetNode = this.nodes.get(particle.targetId);
                        if (sourceNode && targetNode) {
                            const t = particle.progress;
                            particle.mesh.position.lerpVectors(
                                sourceNode.position,
                                targetNode.position,
                                t
                            );
                        }
                    }
                }
            }

            spawnFlowParticle(sourceId, targetId, color = 0x00ffff) {
                const sourceNode = this.nodes.get(sourceId);
                const targetNode = this.nodes.get(targetId);
                if (!sourceNode || !targetNode) return;

                const mesh = new THREE.Mesh(
                    this.particleGeometry,
                    new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                mesh.position.copy(sourceNode.position);
                this.scene.add(mesh);

                this.flowParticles.push({
                    mesh: mesh,
                    sourceId: sourceId,
                    targetId: targetId,
                    progress: 0,
                    speed: 0.5 + Math.random() * 0.5
                });
            }

            // --------------------------------------------------------
            // WebSocket
            // --------------------------------------------------------

            initWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;

                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    this.setConnectionStatus(true);
                    this.addLog('system', 'Connected to DET server');
                };

                this.ws.onclose = () => {
                    this.setConnectionStatus(false);
                    this.addLog('system', 'Disconnected from server');
                    // Reconnect after delay
                    setTimeout(() => this.initWebSocket(), 3000);
                };

                this.ws.onerror = (error) => {
                    this.addLog('error', 'WebSocket error');
                };

                this.ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    this.handleMessage(msg);
                };
            }

            handleMessage(msg) {
                switch (msg.type) {
                    case 'init':
                        this.handleInit(msg.data);
                        break;
                    case 'state':
                        this.handleState(msg.data);
                        break;
                    case 'event':
                        this.handleEvent(msg.data);
                        break;
                    case 'chat_response':
                        this.handleChatResponse(msg.data);
                        break;
                    case 'chat_error':
                        this.handleChatError(msg.data);
                        break;
                    case 'ping':
                        this.ws.send(JSON.stringify({ type: 'pong' }));
                        break;
                }
            }

            handleInit(data) {
                this.state = {
                    tick: data.tick || 0,
                    paused: data.paused || false,
                    speed: data.speed || 1.0,
                    numActive: data.num_active || 0,
                    numBonds: data.num_bonds || 0,
                };

                if (data.nodes) {
                    this.updateNodes(data.nodes);
                }
                if (data.bonds) {
                    this.updateBonds(data.bonds);
                }

                this.updateUI(data);
                this.addLog('system', 'Initialized with full state');
            }

            handleState(data) {
                this.state.tick = data.tick;
                this.state.paused = data.paused;
                this.state.speed = data.speed;
                this.state.numActive = data.num_active;
                this.state.numBonds = data.num_bonds;

                // Update 3D visualization if nodes/bonds included
                if (data.nodes && data.nodes.length > 0) {
                    this.updateNodes(data.nodes);
                }
                if (data.bonds) {
                    this.updateBonds(data.bonds);
                }

                this.updateUI(data);
            }

            handleEvent(event) {
                this.addLog(event.type, JSON.stringify(event.params));
            }

            // --------------------------------------------------------
            // 3D Visualization
            // --------------------------------------------------------

            updateNodes(nodesData) {
                // Track which nodes still exist
                const existingIds = new Set(this.nodes.keys());
                const newIds = new Set(nodesData.map(n => n.id));

                // Remove nodes that no longer exist
                existingIds.forEach(id => {
                    if (!newIds.has(id)) {
                        const mesh = this.nodes.get(id);
                        if (mesh) this.scene.remove(mesh);
                        this.nodes.delete(id);
                        this.nodePositions.delete(id);
                        this.nodeTargets.delete(id);
                    }
                });

                // Create or update nodes
                nodesData.forEach(node => {
                    // Update target position (for smooth movement)
                    this.nodeTargets.set(node.id, { x: node.x, y: node.y, z: node.z });

                    if (this.nodes.has(node.id)) {
                        // Update existing node
                        const mesh = this.nodes.get(node.id);
                        const color = new THREE.Color(
                            node.color?.r || 0.5,
                            node.color?.g || 0.5,
                            node.color?.b || 0.5
                        );
                        mesh.material.color = color;
                        mesh.material.emissive = node.in_self ? new THREE.Color(0x00d4ff) : new THREE.Color(0x000000);
                        mesh.material.emissiveIntensity = node.in_self ? 0.4 : 0;
                        mesh.userData = node;

                        // Scale based on activity
                        const scale = 0.8 + node.P * 0.4;
                        mesh.scale.setScalar(scale);
                    } else {
                        // Create new node
                        const baseSize = node.size || 0.1;
                        const geometry = new THREE.SphereGeometry(baseSize, 12, 12);
                        const color = new THREE.Color(
                            node.color?.r || 0.5,
                            node.color?.g || 0.5,
                            node.color?.b || 0.5
                        );

                        const material = new THREE.MeshPhongMaterial({
                            color: color,
                            emissive: node.in_self ? new THREE.Color(0x00d4ff) : new THREE.Color(0x000000),
                            emissiveIntensity: node.in_self ? 0.4 : 0,
                            shininess: 50,
                        });

                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(node.x, node.y, node.z);
                        mesh.userData = node;

                        this.scene.add(mesh);
                        this.nodes.set(node.id, mesh);

                        // Initialize position tracking for smooth movement
                        this.nodePositions.set(node.id, {
                            x: node.x, y: node.y, z: node.z,
                            vx: 0, vy: 0, vz: 0
                        });
                    }
                });
            }

            updateBonds(bondsData) {
                // Clear existing bonds
                this.bonds.forEach(bondObj => {
                    if (bondObj.line) this.scene.remove(bondObj.line);
                    if (bondObj.glow) this.scene.remove(bondObj.glow);
                });
                this.bonds = [];

                // Create new bonds with enhanced visualization
                bondsData.forEach(bond => {
                    const sourceNode = this.nodes.get(bond.source);
                    const targetNode = this.nodes.get(bond.target);

                    if (sourceNode && targetNode) {
                        // Main bond line
                        const positions = new Float32Array([
                            sourceNode.position.x, sourceNode.position.y, sourceNode.position.z,
                            targetNode.position.x, targetNode.position.y, targetNode.position.z
                        ]);
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                        // Color based on bond type
                        let bondColor = 0x00d4ff;  // Default: cyan
                        if (bond.is_cross_layer) {
                            bondColor = 0xff8800;  // Cross-layer: orange
                        } else if (bond.C > 0.7) {
                            bondColor = 0x00ff88;  // Strong: green
                        }

                        const material = new THREE.LineBasicMaterial({
                            color: bondColor,
                            transparent: true,
                            opacity: 0.3 + bond.strength * 0.5,
                            linewidth: 1,
                        });

                        const line = new THREE.Line(geometry, material);
                        this.scene.add(line);

                        // Store bond with metadata for position updates
                        const bondObj = {
                            line: line,
                            sourceId: bond.source,
                            targetId: bond.target,
                            strength: bond.strength,
                            flux: bond.flux || 0
                        };
                        this.bonds.push(bondObj);

                        // Spawn flow particles for high-flux bonds
                        if (bond.flux > 0.1 && Math.random() < bond.flux * 0.3) {
                            const particleColor = bond.is_cross_layer ? 0xffaa00 : 0x00ffff;
                            this.spawnFlowParticle(bond.source, bond.target, particleColor);
                        }
                    }
                });
            }

            // --------------------------------------------------------
            // UI Updates
            // --------------------------------------------------------

            updateUI(data) {
                // Overlay info
                document.getElementById('info-tick').textContent = data.tick || 0;
                document.getElementById('info-nodes').textContent = data.num_active || 0;
                document.getElementById('info-bonds').textContent = data.num_bonds || 0;
                document.getElementById('info-self').textContent = data.self_cluster_size || 0;

                // Status cards
                if (data.aggregates) {
                    document.getElementById('stat-presence').textContent = (data.aggregates.presence || 0).toFixed(3);
                    document.getElementById('stat-coherence').textContent = (data.aggregates.coherence || 0).toFixed(3);
                    document.getElementById('stat-resource').textContent = (data.aggregates.resource || 0).toFixed(3);
                    document.getElementById('stat-debt').textContent = (data.aggregates.debt || 0).toFixed(3);
                }

                // Emotional state
                document.getElementById('stat-emotion').textContent = data.emotional_state || 'UNKNOWN';

                // Affect bars
                if (data.affect) {
                    const valence = data.affect.valence || 0;
                    const arousal = data.affect.arousal || 0;
                    const bondedness = data.affect.bondedness || 0;

                    document.getElementById('affect-valence-val').textContent = valence.toFixed(2);
                    document.getElementById('affect-arousal-val').textContent = arousal.toFixed(2);
                    document.getElementById('affect-bondedness-val').textContent = bondedness.toFixed(2);

                    // Valence bar (centered, -1 to 1)
                    document.getElementById('affect-valence-bar').style.width = `${((valence + 1) / 2) * 100}%`;
                    document.getElementById('affect-arousal-bar').style.width = `${arousal * 100}%`;
                    document.getElementById('affect-bondedness-bar').style.width = `${bondedness * 100}%`;
                }

                // Speed slider
                document.getElementById('speed-value').textContent = `${(data.speed || 1.0).toFixed(1)}x`;

                // Pause/Resume button states and indicator
                const pauseBtn = document.getElementById('btn-pause');
                const resumeBtn = document.getElementById('btn-resume');
                const pausedIndicator = document.getElementById('paused-indicator');
                if (data.paused) {
                    pauseBtn.disabled = true;
                    pauseBtn.classList.add('btn-disabled');
                    resumeBtn.disabled = false;
                    resumeBtn.classList.remove('btn-disabled');
                    resumeBtn.classList.add('btn-success');
                    pausedIndicator.style.display = 'block';
                } else {
                    pauseBtn.disabled = false;
                    pauseBtn.classList.remove('btn-disabled');
                    resumeBtn.disabled = true;
                    resumeBtn.classList.add('btn-disabled');
                    resumeBtn.classList.remove('btn-success');
                    pausedIndicator.style.display = 'none';
                }
            }

            updateNodeList(nodes) {
                const container = document.getElementById('node-list');
                container.innerHTML = '';

                nodes.forEach(node => {
                    const div = document.createElement('div');
                    div.className = `node-item ${node.in_self ? 'in-self' : ''}`;

                    const color = node.color || { r: 0.5, g: 0.5, b: 0.5 };
                    const colorStr = `rgb(${Math.floor(color.r * 255)}, ${Math.floor(color.g * 255)}, ${Math.floor(color.b * 255)})`;

                    div.innerHTML = `
                        <div class="dot" style="background: ${colorStr};"></div>
                        <div class="info">
                            <div class="name">${node.layer}-${node.id}</div>
                            <div class="stats">P: ${node.P?.toFixed(2) || '?'} | a: ${node.a?.toFixed(2) || '?'}</div>
                        </div>
                    `;

                    container.appendChild(div);
                });
            }

            // --------------------------------------------------------
            // Controls
            // --------------------------------------------------------

            initControls() {
                // Step buttons
                document.getElementById('btn-step').addEventListener('click', () => {
                    this.sendCommand('step', { n: 1, dt: 0.1 });
                });

                document.getElementById('btn-step10').addEventListener('click', () => {
                    this.sendCommand('step', { n: 10, dt: 0.1 });
                });

                // Pause/Resume
                document.getElementById('btn-pause').addEventListener('click', () => {
                    this.sendCommand('pause');
                });

                document.getElementById('btn-resume').addEventListener('click', () => {
                    this.sendCommand('resume');
                });

                // Speed slider
                const speedSlider = document.getElementById('speed-slider');
                speedSlider.addEventListener('input', (e) => {
                    const speed = parseFloat(e.target.value);
                    document.getElementById('speed-value').textContent = `${speed.toFixed(1)}x`;
                });
                speedSlider.addEventListener('change', (e) => {
                    const speed = parseFloat(e.target.value);
                    this.sendCommand('speed', { speed });
                });

                // Snapshot
                document.getElementById('btn-snapshot').addEventListener('click', () => {
                    const name = `snap_${Date.now()}`;
                    this.sendCommand('snapshot', { name });
                    this.addLog('snapshot', `Saved: ${name}`);
                });

                // Inject
                document.getElementById('btn-inject').addEventListener('click', () => {
                    const node = parseInt(document.getElementById('inject-node').value) || 0;
                    const amount = parseFloat(document.getElementById('inject-amount').value) || 0.5;
                    this.sendCommand('inject_f', { node, amount });
                });

                // Clear log
                document.getElementById('btn-clear-log').addEventListener('click', () => {
                    this.logs = [];
                    document.getElementById('log-container').innerHTML = '';
                });
            }

            sendCommand(type, params = {}) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ type, ...params }));
                }
            }

            // --------------------------------------------------------
            // Tabs
            // --------------------------------------------------------

            initTabs() {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabId = tab.dataset.tab;

                        // Update tab buttons
                        tabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');

                        // Update tab panes
                        document.querySelectorAll('.tab-pane').forEach(pane => {
                            pane.classList.remove('active');
                        });
                        document.getElementById(`tab-${tabId}`).classList.add('active');
                    });
                });
            }

            // --------------------------------------------------------
            // Logging
            // --------------------------------------------------------

            addLog(type, message) {
                const now = new Date();
                const timeStr = now.toLocaleTimeString();

                this.logs.push({ time: timeStr, type, message });
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }

                const container = document.getElementById('log-container');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.innerHTML = `
                    <span class="time">${timeStr}</span>
                    <span class="type">${type}</span>
                    <span class="message">${message}</span>
                `;
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
            }

            setConnectionStatus(connected) {
                const status = document.getElementById('connection-status');
                if (connected) {
                    status.className = 'connection-status connected';
                    status.textContent = 'Connected';
                } else {
                    status.className = 'connection-status disconnected';
                    status.textContent = 'Disconnected';
                }
            }

            // --------------------------------------------------------
            // Chat Interface
            // --------------------------------------------------------

            initChat() {
                const input = document.getElementById('chat-input');
                const sendBtn = document.getElementById('chat-send');

                // Send on button click
                sendBtn.addEventListener('click', () => this.sendChatMessage());

                // Send on Enter (but Shift+Enter for new line)
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendChatMessage();
                    }
                });
            }

            sendChatMessage() {
                const input = document.getElementById('chat-input');
                const message = input.value.trim();

                if (!message || this.chatProcessing) return;

                // Add user message to chat
                this.addChatMessage('user', message);

                // Clear input
                input.value = '';

                // Set processing state
                this.setChatProcessing(true);

                // Send to server
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'chat',
                        message: message
                    }));
                } else {
                    this.handleChatError({ error: 'Not connected to server' });
                }
            }

            handleChatResponse(data) {
                this.setChatProcessing(false);

                if (data.response) {
                    this.addChatMessage('assistant', data.response);
                }

                // Log decision info
                if (data.decision) {
                    this.addLog('chat', `Decision: ${data.decision}`);
                }
            }

            handleChatError(data) {
                this.setChatProcessing(false);
                this.addChatMessage('system', `Error: ${data.error || 'Unknown error'}`);
            }

            addChatMessage(type, content) {
                const container = document.getElementById('chat-messages');
                const div = document.createElement('div');
                div.className = `chat-message ${type}`;

                const senderNames = {
                    user: 'You',
                    assistant: 'DET',
                    system: 'System'
                };

                div.innerHTML = `
                    <div class="sender">${senderNames[type] || type}</div>
                    <div class="content">${this.escapeHtml(content)}</div>
                `;

                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
            }

            setChatProcessing(processing) {
                this.chatProcessing = processing;
                const status = document.getElementById('chat-status');
                const sendBtn = document.getElementById('chat-send');

                if (processing) {
                    status.textContent = 'Processing...';
                    status.className = 'chat-status processing';
                    sendBtn.disabled = true;
                } else {
                    status.textContent = 'Ready';
                    status.className = 'chat-status';
                    sendBtn.disabled = false;
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // --------------------------------------------------------
            // Somatic Controls
            // --------------------------------------------------------

            initSomatic() {
                // Create button
                document.getElementById('btn-create-somatic').addEventListener('click', () => {
                    const typeSelect = document.getElementById('somatic-type-select');
                    const nameInput = document.getElementById('somatic-name-input');
                    const type = parseInt(typeSelect.value);
                    const name = nameInput.value.trim();

                    if (!name) {
                        this.addLog('error', 'Please enter a node name');
                        return;
                    }

                    this.createSomaticNode(type, name);
                    nameInput.value = '';
                });

                // Simulate button
                document.getElementById('btn-simulate-somatic').addEventListener('click', () => {
                    this.simulateSomatic();
                });

                // Refresh button
                document.getElementById('btn-refresh-somatic').addEventListener('click', () => {
                    this.fetchSomaticList();
                });

                // Initial fetch
                this.fetchSomaticList();
            }

            async fetchSomaticList() {
                try {
                    const response = await fetch('/api/somatic');
                    const data = await response.json();
                    this.renderSomaticList(data.somatic || []);
                } catch (error) {
                    this.addLog('error', `Failed to fetch somatic list: ${error.message}`);
                }
            }

            renderSomaticList(somaticNodes) {
                const container = document.getElementById('somatic-list');
                const countSpan = document.getElementById('somatic-count');

                countSpan.textContent = `(${somaticNodes.length})`;

                if (somaticNodes.length === 0) {
                    container.innerHTML = '<div class="somatic-empty">No somatic nodes. Create one above.</div>';
                    return;
                }

                container.innerHTML = '';

                somaticNodes.forEach((node, idx) => {
                    const isSensor = node.is_sensor;
                    const nodeClass = isSensor ? 'sensor' : 'actuator';
                    const typeBadge = isSensor ? 'Sensor' : 'Actuator';

                    const div = document.createElement('div');
                    div.className = `somatic-item ${nodeClass}`;
                    div.dataset.idx = idx;

                    // Build the control row based on type
                    let controlHtml = '';
                    if (isSensor) {
                        // Sensors: show value slider for manual override
                        controlHtml = `
                            <div class="slider-container">
                                <span style="font-size: 0.7rem; color: #888;">Val:</span>
                                <input type="range" min="0" max="1" step="0.01" value="${node.value.toFixed(2)}"
                                    class="somatic-value-slider" data-idx="${idx}">
                                <span class="slider-value">${node.value.toFixed(2)}</span>
                            </div>
                        `;
                    } else {
                        // Actuators: show target slider
                        controlHtml = `
                            <div class="slider-container">
                                <span style="font-size: 0.7rem; color: #888;">Target:</span>
                                <input type="range" min="0" max="1" step="0.01" value="${node.target.toFixed(2)}"
                                    class="somatic-target-slider" data-idx="${idx}">
                                <span class="slider-value">${node.target.toFixed(2)}</span>
                            </div>
                        `;
                    }

                    div.innerHTML = `
                        <div class="header">
                            <span class="name">${this.escapeHtml(node.name)}</span>
                            <span class="type-badge">${typeBadge}</span>
                        </div>
                        <div class="values">
                            <span>Type: <span class="val">${this.escapeHtml(node.type_name)}</span></span>
                            <span>Value: <span class="val somatic-value-display">${node.value.toFixed(3)}</span></span>
                            ${!isSensor ? `<span>Output: <span class="val">${node.output.toFixed(3)}</span></span>` : ''}
                        </div>
                        <div class="control-row">
                            ${controlHtml}
                            <button class="btn-remove" data-idx="${idx}">Remove</button>
                        </div>
                    `;

                    container.appendChild(div);
                });

                // Attach event listeners for sliders and remove buttons
                container.querySelectorAll('.somatic-value-slider').forEach(slider => {
                    slider.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        e.target.parentElement.querySelector('.slider-value').textContent = val.toFixed(2);
                    });
                    slider.addEventListener('change', (e) => {
                        const idx = parseInt(e.target.dataset.idx);
                        const val = parseFloat(e.target.value);
                        this.updateSomaticValue(idx, val);
                    });
                });

                container.querySelectorAll('.somatic-target-slider').forEach(slider => {
                    slider.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        e.target.parentElement.querySelector('.slider-value').textContent = val.toFixed(2);
                    });
                    slider.addEventListener('change', (e) => {
                        const idx = parseInt(e.target.dataset.idx);
                        const val = parseFloat(e.target.value);
                        this.setSomaticTarget(idx, val);
                    });
                });

                container.querySelectorAll('.btn-remove').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const idx = parseInt(e.target.dataset.idx);
                        this.removeSomaticNode(idx);
                    });
                });
            }

            async createSomaticNode(type, name) {
                try {
                    const response = await fetch('/api/somatic/create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            type: type,
                            name: name,
                            is_virtual: true
                        })
                    });
                    const data = await response.json();

                    if (data.success) {
                        this.addLog('somatic', `Created: ${name} (idx=${data.somatic_idx})`);
                        this.fetchSomaticList();
                    } else {
                        this.addLog('error', `Failed to create: ${data.error || 'Unknown error'}`);
                    }
                } catch (error) {
                    this.addLog('error', `Create failed: ${error.message}`);
                }
            }

            async removeSomaticNode(idx) {
                try {
                    const response = await fetch('/api/somatic/remove', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ somatic_idx: idx })
                    });
                    const data = await response.json();

                    if (data.success) {
                        this.addLog('somatic', `Removed node at idx=${idx}`);
                        this.fetchSomaticList();
                    } else {
                        this.addLog('error', `Failed to remove: ${data.error || 'Unknown error'}`);
                    }
                } catch (error) {
                    this.addLog('error', `Remove failed: ${error.message}`);
                }
            }

            async setSomaticTarget(idx, target) {
                try {
                    const response = await fetch('/api/somatic/set_target', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ somatic_idx: idx, target: target })
                    });
                    const data = await response.json();

                    if (data.success) {
                        this.addLog('somatic', `Set target for idx=${idx} to ${target.toFixed(2)}`);
                    } else {
                        this.addLog('error', `Failed to set target: ${data.error || 'Unknown error'}`);
                    }
                } catch (error) {
                    this.addLog('error', `Set target failed: ${error.message}`);
                }
            }

            async updateSomaticValue(idx, value) {
                try {
                    const response = await fetch('/api/somatic/update_value', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ somatic_idx: idx, value: value })
                    });
                    const data = await response.json();

                    if (data.success) {
                        this.addLog('somatic', `Updated value for idx=${idx} to ${value.toFixed(2)}`);
                    } else {
                        this.addLog('error', `Failed to update value: ${data.error || 'Unknown error'}`);
                    }
                } catch (error) {
                    this.addLog('error', `Update value failed: ${error.message}`);
                }
            }

            async simulateSomatic() {
                try {
                    // Send step command then refresh
                    this.sendCommand('step', { n: 1, dt: 0.1 });
                    // Also call simulate on backend
                    const response = await fetch('/api/somatic/simulate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ dt: 0.1 })
                    });
                    // Refresh the list after simulation
                    setTimeout(() => this.fetchSomaticList(), 100);
                } catch (error) {
                    this.addLog('error', `Simulate failed: ${error.message}`);
                }
            }

            // --------------------------------------------------------
            // Animation Loop
            // --------------------------------------------------------

            animate() {
                requestAnimationFrame(() => this.animate());

                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            window.viewer = new DETViewer();
        });
    </script>
</body>
</html>
